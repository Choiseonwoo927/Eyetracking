<!DOCTYPE html>
<html>

<head>
    <title>가천대학교 제4회 학술제 인지 실험</title>
    <!-- Eyetracking tools: Webgazer using Javascript language -->
    <script src="https://webgazer.cs.brown.edu/webgazer.js" type="text/javascript"></script>
    <style>
        body {
            text-align: center;
        }

        /* the format of the stimuli */
        #stimulus-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            justify-content: center;
            align-items: center;
            width: 800px;
            height: 600px;
        }

        /* the format of the message*/
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }

        /* the format of the consent below the code */
        #consent-area {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            text-align: left;
        }

        #consent-text {
            border: 1px solid #ccc;
            padding: 15px;
            margin-bottom: 20px;
        }

        #consent-area label {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.1em;
            margin-top: 20px;
        }

        /* the format of the calibration */
        #calibration-area {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: none;
            cursor: crosshair;
        }

        .calibration-point {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: red;
            position: absolute;
            cursor: pointer;
            z-index: 2001;
            display: none;
            line-height: 25px;
            color: white;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>

<body>
    <div id="calibration-area">
        <p id="cal-instructions"
            style="color: white; position: absolute; top: 10%; left: 50%; transform: translate(-50%); font-size: 1.5em; z-index: 2002;">
        </p>
    </div>

    <div id="message">
        <!-- intro of the experiment -->
        <p style="font-size: 1.3em;"> 안녕하세요. 가천대학교 심리학과 김에스더, 서해리, 안다온, 이지흠, 최선우, 황은석입니다. </p>

        <p style="font-weight: bold; font-size: 1.5em;"> 위 실험은 제4회 가천대학교 심리학과 학술제에서 그림-글자 자극의 배치와 일치성이 시각작업기억에 미치는 영향을
            실험하고자 합니다. </p>

        <p style="font-size: 1.5em; font-weight: bold; color: red;">실험 1은 자극(그림-글자, 글자-그림)이 일치하면 'z'키를, 불일치하면 '/'키를
            눌러주세요.</p>

        <p style="font-size: 1.5em; font-weight: bold; color: red;">실험 2는 실험1에 제시된 자극(쌍과 순서가 동일해야 함.)이면 'z'키를, 미제시 자극(쌍,
            순서 등)이면 '/'키를 눌러주세요.</p>

        <p style="font-size: 1.3em;"> 본 실험은 대략 3분 ~ 5분 가량 소요될 예정입니다.</p>

        <p style="font-size: 1.3em;"> 실험을 시작하려면 '시작하기'를 클릭하세요. </p>
        <button onclick="startExperiment()">시작하기</button>
    </div>

    <script>
        // setting the first variables
        let allStimuli = [];
        let exp2Stimuli = [];
        let practiceStimuli = [];
        let experiment1Data = [];
        let experiment2Data = [];
        let currentTrialGazeData = [];
        let trialStartTime = 0;
        let responseHandler = null;
        let isPracticePhase = true;
        let currentPracticeTrialIndex = 0;
        let currentTrialIndex = 0;
        let currentExperimentNumber = 1;

        // setting the calibration variables
        const CALIBRATION_POINTS = [
            [5, 5], [50, 5], [95, 5],
            [5, 50], [50, 50], [95, 50],
            [5, 95], [50, 95], [95, 95]
        ];
        const CLICKS_PER_POINT = 5;
        let currentCalibrationPointIndex = 0;
        let currentCalibrationClicks = 0;
        let calibrationInProgress = false;

        // spreadsheet urls for the save experiment data
        const SPREADSHEET_URL_EXP1 = 'https://script.google.com/macros/s/AKfycbwuwNsk6BrLoGslQRQpFrutmbozG-YpEbbgtYzoho8blXHoqbqd9EPuOS3cNhIQ7IoV/exec';
        const SPREADSHEET_URL_EXP2 = 'https://script.google.com/macros/s/AKfycbwq_ksQ0-hEMzZyscUWUdxUtU36ypS45RFGJjmeDYhG8IgLDP8oC-Mal_2HONcdz6sh/exec';

        // Github urls for the stimuli
        const stimuli_json_url_exp1 = 'https://Choiseonwoo927.github.io/Eyetracking/conditions/total_cond.json'; // experiment 1
        const stimuli_json_url_exp2 = 'https://Choiseonwoo927.github.io/Eyetracking/conditions2/total_cond2.json'; // experiment 2
        const practice_stimuli_json_url = 'https://Choiseonwoo927.github.io/Eyetracking/practice_cond/practice_total.json'; // practice experiment

        // randomly shuffle to the stimuili for random assignment of stimuli conditions
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // load the practice stimuli
        // condition: congruent, incongruent, cong_same(duplication of congruent stim), incong_same(duplication of incongruent stim)
        async function loadPracticeStimuli() {
            try {
                const response = await fetch(practice_stimuli_json_url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();

                practiceStimuli = data.congruent.map(url => ({ url, congruency: 'congruent' }))
                    .concat(
                        data.incongruent.map(url => ({ url, congruency: 'incongruent' })),
                        data.cong_same.map(url => ({ url, congruency: 'cong_same' })),
                        data.incong_same.map(url => ({ url, congruency: 'incong_same' }))
                    );
            } catch (error) {
                console.error('연습 자극 파일을 불러오는 데 실패했습니다:', error);
                document.getElementById('message').innerHTML = '<p style="color:red;">연습 자극 파일을 불러오는 데 문제가 있습니다. 실험 담당자에게 연락 바랍니다.</p>';
            }
        }

        // load the experiment 1 stimuli
        // condition: congruent, incongruent, cong_same, incong_same
        async function loadStimuliExp1() {
            try {
                const response = await fetch(stimuli_json_url_exp1);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                allStimuli = shuffle(
                    data.congruent.map(url => ({ url, congruency: 'congruent' }))
                        .concat(
                            data.incongruent.map(url => ({ url, congruency: 'incongruent' })),
                            data.cong_same.map(url => ({ url, congruency: 'cong_same' })),
                            data.incong_same.map(url => ({ url, congruency: 'incong_same' }))
                        )
                );
            } catch (error) {
                console.error('자극 파일을 불러오는 데 실패했습니다:', error);
                document.getElementById('message').innerHTML = '<p style="color:red;">자극 파일을 불러오는 데 문제가 있습니다. 실험 담당자에게 연락 바랍니다.</p>';
            }
        }

        // load the experiment 2 stimuli
        // condition: congruent, incongruent, nonebefore(not include stim of the previous experiment)
        async function loadStimuliExp2() {
            try {
                const response = await fetch(stimuli_json_url_exp2);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                exp2Stimuli = shuffle(
                    data.congruent.map(url => ({ url, congruency: 'congruent' }))
                        .concat(
                            data.incongruent.map(url => ({ url, congruency: 'incongruent' })),
                            data.cong_none.map(url => ({ url, congruency: 'cong_none' })),
                            data.incong_none.map(url => ({ url, congruency: 'incong_none' }))
                        )
                );
            } catch (error) {
                console.error('자극 파일을 불러오는 데 실패했습니다:', error);
                document.getElementById('message').innerHTML = '<p style="color:red;">자극 파일을 불러오는 데 문제가 있습니다. 실험 담당자에게 연락 바랍니다.</p>';
            }
        }

        // calibration function
        function startCalibration() {
            calibrationInProgress = true;
            const calArea = document.getElementById('calibration-area');
            const instructions = document.getElementById('cal-instructions');
            calArea.style.display = 'block';
            instructions.innerHTML = '빨간 점을 **응시하면서** 5번씩 클릭해 주세요.';

            // generate calibration points
            CALIBRATION_POINTS.forEach((point, index) => {
                const pointElement = document.createElement('div');
                pointElement.classList.add('calibration-point');
                pointElement.id = `cal-point-${index}`;
                // coordinate of the point on the screen center
                pointElement.style.left = `calc(${point[0]}% - 25px)`;
                pointElement.style.top = `calc(${point[1]}% - 25px)`;
                pointElement.onclick = handleCalibrationClick;
                pointElement.innerHTML = index + 1;
                calArea.appendChild(pointElement);
            });

            currentCalibrationPointIndex = 0;
            currentCalibrationClicks = 0;
            webgazer.clearData(); // clear the gaze data
            showNextCalibrationPoint();
        }

        function showNextCalibrationPoint() {
            const points = document.querySelectorAll('.calibration-point');

            if (currentCalibrationPointIndex >= CALIBRATION_POINTS.length) {
                finishCalibration();
                return;
            }

            points.forEach(p => p.style.display = 'none');

            // display the next calibration point
            const currentPoint = points[currentCalibrationPointIndex];
            currentPoint.style.display = 'flex';
            currentPoint.style.justifyContent = 'center';
            currentPoint.style.alignItems = 'center';

            const instructions = document.getElementById('cal-instructions');
            instructions.innerHTML = `<p>현재 지점: ${currentCalibrationPointIndex + 1} / ${CALIBRATION_POINTS.length}. ${currentCalibrationClicks} / ${CLICKS_PER_POINT}번 클릭</p>
            <p stlye = "font-weight: bold;">빨간 점을 응시하면서 클릭해 주세요.</p>
            <p> 점의 색깔이 초록색이 되면 성공입니다. </p>`;
        }

        function handleCalibrationClick(event) {
            if (!calibrationInProgress) return;

            const pointElement = event.target;

            // take the WebGazer calibration data
            // learn the position of the calibration point
            webgazer.recordScreenPosition(event.clientX, event.clientY, "click");

            currentCalibrationClicks++;

            // visual feedback of the click
            pointElement.style.backgroundColor = 'green';
            setTimeout(() => pointElement.style.backgroundColor = 'red', 100);

            const instructions = document.getElementById('cal-instructions');
            instructions.innerHTML = `<p>현재 지점: ${currentCalibrationPointIndex + 1} / ${CALIBRATION_POINTS.length}. ${currentCalibrationClicks} / ${CLICKS_PER_POINT}번 클릭</p>
            <p stlye = "font-weight: bold;">빨간 점을 응시하면서 클릭해 주세요.</p>
            <p> 점의 색깔이 초록색이 되면 성공입니다. </p>`;


            if (currentCalibrationClicks >= CLICKS_PER_POINT) {
                currentCalibrationPointIndex++;
                currentCalibrationClicks = 0;
                // 0.5s delay
                setTimeout(showNextCalibrationPoint, 500);
            }
        }

        function finishCalibration() {
            calibrationInProgress = false;
            const calArea = document.getElementById('calibration-area');
            calArea.style.display = 'none';

            webgazer.showPredictionPoints(false);

            document.querySelectorAll('.calibration-point').forEach(p => p.remove());

            const messageDiv = document.getElementById('message');
            messageDiv.style.display = 'block';
            messageDiv.innerHTML = `<p style="font-size: 1.5em; color: green; font-weight: bold;">캘리브레이션이 완료되었습니다!</p>`;

            // after 2s, show the next practice trial
            setTimeout(() => {
                messageDiv.style.display = 'none';
                showNextPracticeTrial();
            }, 2000);
        }

        // run a trial of all experiment
        function runTrial(stimulus, isPractice) {
            const messageDiv = document.getElementById('message');
            if (messageDiv) {
                messageDiv.style.display = 'none';
            }

            let stimulusContainer = document.getElementById('stimulus-container');
            if (!stimulusContainer) {
                stimulusContainer = document.createElement('div');
                stimulusContainer.id = 'stimulus-container';
                document.body.appendChild(stimulusContainer);
            }

            stimulusContainer.innerHTML = '';

            // format of the stim image: 800x600px
            const img = document.createElement('img');
            img.src = stimulus.url;
            img.style.maxWidth = '800px';
            img.style.maxHeight = '600px';
            stimulusContainer.appendChild(img);

            currentTrialGazeData = []; // variables for gaze tracking
            trialStartTime = performance.now(); // trial start time for calculate reaction time(RT)

            // resonse key: 'z' or '/', only two key is allowed
            responseHandler = function (event) {
                if (event.key === 'z' || event.key === '/') {
                    const reactionTime = performance.now() - trialStartTime; // calculate RT

                    stimulusContainer.innerHTML = '';

                    // record the trial data, but not save the practice data in spreadsheet
                    if (!isPractice) {
                        const trialData = {
                            trial_index: currentTrialIndex,
                            stimulus_url: stimulus.url,
                            congruency: stimulus.congruency,
                            response: event.key,
                            reaction_time: reactionTime,
                            experiment_number: currentExperimentNumber
                        };
                        if (currentExperimentNumber === 1) { // only record gaze data in experiment 1, not experiment 2
                            trialData.gaze_data = currentTrialGazeData;
                            experiment1Data.push(trialData);
                        } else {
                            experiment2Data.push(trialData);
                        }

                        currentTrialIndex++;
                    } else {
                        currentPracticeTrialIndex++;
                    }

                    window.removeEventListener('keydown', responseHandler);

                    if (isPracticePhase) {
                        showNextPracticeTrial();
                    } else {
                        showNextTrial();
                    }
                }
            };
            window.addEventListener('keydown', responseHandler);
        }

        // explain the next practice trial
        function showNextPracticeTrial() {
            if (currentPracticeTrialIndex === 0) {
                const messageDiv = document.getElementById('message');
                messageDiv.innerHTML = `<p style = "font-size: 1.5em;">연습 시행이 곧 시작됩니다.</p>
                <p style = "font-size: 1.5em;">그림과 글자가 일치하면 'z'키를, 불일치하면 '/'키를 눌러주세요. (키보드의 'z', '/' 키로 반응)</p>`;
                messageDiv.style.display = 'block';

                // delay for 5 seconds
                setTimeout(() => {
                    messageDiv.style.display = 'none';
                    runTrial(practiceStimuli[currentPracticeTrialIndex], true);
                }, 5000);

            } else if (currentPracticeTrialIndex < practiceStimuli.length) {
                const practiceStim = practiceStimuli[currentPracticeTrialIndex];
                runTrial(practiceStim, true);
            } else {
                isPracticePhase = false;
                const messageDiv = document.getElementById('message');
                messageDiv.style.display = 'block';
                messageDiv.innerHTML = `<p style="font-size: 1.5em;">연습이 끝났습니다. 이제 본 실험이 시작됩니다.</p>`;

                setTimeout(() => {
                    messageDiv.style.display = 'none';
                    showNextTrial();
                }, 5000);
            }
        }

        // explain the next trial both experiment 1, 2
        function showNextTrial() {
            const currentStimuliSet = currentExperimentNumber === 1 ? allStimuli : exp2Stimuli;
            if (currentTrialIndex < currentStimuliSet.length) {
                const currentStim = currentStimuliSet[currentTrialIndex];

                const messageDiv = document.getElementById('message');
                messageDiv.style.display = 'block';

                if (currentTrialIndex === 0) {
                    if (currentExperimentNumber === 1) {
                        // text for experiment 1 in the first trial
                        messageDiv.innerHTML = `<p style  = "font-size: 1.5em; font-weight: bold;">그림과 글자가 일치하면 'z'키를, 불일치하면 '/'키를 눌러주세요.</p><p style = "font-size: 1.3em;">그림과 글자가 일치하면 'z'키를, 불일치하면 '/'키를 눌러주세요. (키보드의 'z', '/' 키로 반응)</p>`;
                    } else if (currentExperimentNumber === 2) {
                        // text for experiment 2 in the first trial
                        messageDiv.innerHTML = `<p style = "font-size: 1.7em; font-weight: bold;">지금부터 제시되는 자극의 쌍이 앞서 있었던 자극인지 반응해주세요.</p>
                                                     <p style = "font-size: 1.7em; font-weight: bold;"> 앞에 있었으면 'z'키를, 앞에 없었으면 '/'키를 눌러주세요. (키보드의 'z', '/' 키로 반응)</p>`;
                    }

                    // delay for 5 seconds before running the trial
                    setTimeout(() => {
                        messageDiv.style.display = 'none';
                        runTrial(currentStim, false);
                    }, 5000);
                } else {
                    runTrial(currentStim, false);
                }
            } else {
                endCurrentExperimentPhase();
            }
        }

        // text of the consent to personal information
        function getConsentText() {
            return `
                <p style="text-align: center; font-size: 1.2em; font-weight: bold;">개인정보 수집 및 이용 동의</p>
                <p>본 실험은 참가자의 시선 데이터를 수집합니다. 수집된 데이터는 연구 목적으로만 활용되며, 개인을 식별할 수 있는 정보는 포함되지 않습니다. 수집된 데이터는 안전하게 보관되며, 연구 종료 후 파기됩니다.</p>
                <p>또한 본 실험은 원활한 실험 결과 수집을 위하여 웹캠이 원활하게 사용 가능한 환경에서 해주시길 바랍니다.</p>
                <p>실험 참여에 동의하십니까? (실험 담당자: 가천대학교 심리학과 최선우, csw1015@gachon.ac.kr)</p>
            `;
        }

        // checkbox of the consent
        async function startExperiment() {
            const messageDiv = document.getElementById('message');
            messageDiv.innerHTML = `
                <div id="consent-area">
                    <div id="consent-text">
                        ${getConsentText()}
                    </div>
                    <label for="consent-checkbox">
                        <input type="checkbox" id="consent-checkbox" style="margin-right: 10px;"> 개인정보 수집 및 이용에 동의합니다.
                    </label>
                </div>
                <button onclick="checkConsent()" style="margin-top: 20px;">동의하고 계속하기</button>
            `;
        }

        async function checkConsent() {
            const consentCheckbox = document.getElementById('consent-checkbox');
            if (consentCheckbox.checked) {
                continueExperiment();
            } else {
                alert('실험 참여를 위해 개인정보 수집 및 이용에 동의해야 합니다.');
            }
        }

        // ready to the experiment
        async function continueExperiment() {
            const messageDiv = document.getElementById('message');
            // message of the acessing webcam
            messageDiv.innerHTML = `<p style = "font-weight: bold; font-size: 1.5em;">웹캠 접근을 허용해주세요...</p>
            <p style = "font-size: 1.3em;">원활한 실험 진행을 위해 왼쪽 상단 웹캠 화면의 박스 칸이 초록색이 되도록 해주세요.</p>`;

            // setting the Gaze Listener
            webgazer.setGazeListener(function (data, elapsedTime) {
                if (data == null) return;
                currentTrialGazeData.push({
                    x: data.x,
                    y: data.y,
                    time: elapsedTime
                });
            });

            // start and setting the WebGazer
            await webgazer.begin();
            webgazer.showPredictionPoints(true);

            // start the calibration
            messageDiv.style.display = 'none';
            startCalibration();

            // loading the stimuli
            await loadPracticeStimuli();
            await loadStimuliExp1();
            await loadStimuliExp2();

            if (practiceStimuli.length === 0 || allStimuli.length === 0 || exp2Stimuli.length === 0) {
                document.getElementById('message').innerHTML = '<p style="color:red;">자극 파일을 불러오는 데 문제가 있습니다. 실험 담당자에게 연락 바랍니다.</p>';
                document.getElementById('message').style.display = 'block';
            }
        }

        function endCurrentExperimentPhase() {
            const stimulusContainer = document.getElementById('stimulus-container');
            if (stimulusContainer) {
                stimulusContainer.remove();
            }

            const messageDiv = document.getElementById('message');
            messageDiv.style.display = 'block';

            if (currentExperimentNumber === 1) {
                // move to the experiment 2
                messageDiv.innerHTML = '<p style="font-size: 3em;">+</p>';
                webgazer.end();
                currentExperimentNumber = 2;
                currentTrialIndex = 0;

                // delay for 5 seconds and display the '+'
                setTimeout(() => {
                    messageDiv.style.display = 'none';
                    showNextTrial();
                }, 5000);
            } else {
                // save the experiment data to the each spreadsheet
                messageDiv.innerHTML = `<p style = "font-size: 1.3em;">실험이 모두 끝났습니다. 데이터를 저장하는 중...</p>
                <p style = "font-size: 1.3em;">위 과정은 몇 분 가량 소요될 수 있습니다.</p>`;

                // send the experiment 1 data
                const saveExp1 = fetch(SPREADSHEET_URL_EXP1, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify(experiment1Data)
                }).then(res => res.json()).catch(err => {
                    console.error('Error saving Exp 1 data:', err);
                    return { result: 'fail' };
                });

                // send the experiment 2 data
                const saveExp2 = fetch(SPREADSHEET_URL_EXP2, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify(experiment2Data)
                }).then(res => res.json()).catch(err => {
                    console.error('Error saving Exp 2 data:', err);
                    return { result: 'fail' };
                });

                Promise.all([saveExp1, saveExp2]).then(results => {
                    const exp1Success = results[0].result === 'success';
                    const exp2Success = results[1].result === 'success';

                    if (exp1Success && exp2Success) {
                        messageDiv.innerHTML = `
                            <p style="color: green; font-size: 1.5em;"> 데이터가 성공적으로 저장되었습니다! </p>
                            <p style="font-size: 1.5em;"> 참여해주셔서 감사합니다. </p>`;
                    } else if (exp1Success) {
                        messageDiv.innerHTML = '<p style="color: red;">실험 2 데이터 저장에 실패했습니다. 실험 담당자에게 연락 바랍니다.</p>';
                    } else if (exp2Success) {
                        messageDiv.innerHTML = '<p style="color: red;">실험 1 데이터 저장에 실패했습니다. 실험 담당자에게 연락 바랍니다.</p>';
                    } else {
                        messageDiv.innerHTML = '<p style="color: red;">데이터 저장에 모두 실패했습니다. 실험 담당자에게 연락 바랍니다.</p>';
                    }
                });
            }
        }
    </script>
</body>

</html>